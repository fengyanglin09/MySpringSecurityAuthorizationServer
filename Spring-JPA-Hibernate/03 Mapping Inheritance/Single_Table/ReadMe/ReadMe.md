This mapping strategy is a winner in terms of both performance and simplicity. It’s the best-performing way to represent polymorphism—both polymorphic and non- polymorphic queries perform well, and it’s even easy to write queries by hand. Ad hoc reporting is possible without complex joins or unions. Schema evolution is straightforward.

There is one major problem: data integrity. We must declare columns for properties declared by subclasses to be nullable. If the subclasses each define several non-nullable properties, the loss of NOT NULL constraints may be a serious problem from the point of view of data correctness. Imagine that an expiration date for credit cards is required, but the database schema can’t enforce this rule because all columns of the table can be NULL. A simple application programming error can lead to invalid data.

Another important concern is normalization. We’ve created functional dependencies between non-key columns, violating the third normal form. As always, denormalization for performance reasons can be misleading because it sacrifices long-term stability, maintainability, and the integrity of data for immediate gains that may also be achieved by proper optimization of the SQL execution plans (in other words, ask the DBA).